#
# Gateways Configuration, refer to the charts/gateways/values.yaml 
# for detailed configuration
#
gateways:
  enabled: true

#
# sidecar-injector webhook configuration, refer to the 
# charts/sidecarInjectorWebhook/values.yaml for detailed configuration
#
sidecarInjectorWebhook:
  enabled: true

#
# galley configuration, refer to charts/galley/values.yaml
# for detailed configuration
#
galley:
  enabled: true

#
# mixer configuration
#
mixer:
  enabled: true

#
# pilot configuration
#
pilot:
  enabled: true

#
# security configuration
#
security:
  enabled: true

#
# nodeagent configuration
#
nodeagent:
  enabled: false

#
# ingress configuration
#
ingress:
  enabled: false

#
# addon grafana configuration
#
grafana:
  enabled: false

#
# addon prometheus configuration
#
prometheus:
  enabled: true

#
# addon servicegraph configuration
#
servicegraph:
  enabled: false

#
# addon jeager tracing configuration
#
tracing:
  enabled: false

#
# addon kiali tracing configuration
#
kiali:
  enabled: false

# Common settings used among istio subcharts.
global:
  # Default hub for Istio images.
  # Releases are published to docker hub under 'istio' project.
  # Daily builds from prow are on gcr.io, and nightly builds from circle on docker.io/istionightly
  hub: gcr.io/istio-release

  # Default tag for Istio images.
  tag: master-latest-daily

  k8sIngress:
    enabled: false
    # Gateway used for legacy k8s Ingress resources. By default it is
    # using 'istio:ingress', to match 0.8 config. It requires that
    # ingress.enabled is set to true. You can also set it
    # to ingressgateway, or any other gateway you define in the 'gateway'
    # section.
    gatewayName: ingress
    # enableHttps will add port 443 on the ingress.
    # It REQUIRES that the certificates are installed  in the
    # expected secrets - enabling this option without certificates
    # will result in LDS rejection and the ingress will not work.
    enableHttps: false
 
  proxy:
    image: proxyv2

    # Resources for the sidecar.
    resources:
      requests:
        cpu: 10m
      #  memory: 128Mi
      # limits:
      #   cpu: 100m
      #   memory: 128Mi

    # Controls number of Proxy worker threads.
    # If set to 0 (default), then start worker thread for each CPU thread/core.
    concurrency: 0

    # Configures the access log for each sidecar. Setting it to an empty string will
    # disable access log for sidecar.
    accessLogFile: "/dev/stdout"

    # If set, newly injected sidecars will have core dumps enabled. Core dumps will always be written to the same
    # file to prevent storage filling up indefinitely. Add a timestamp option to core_pattern to keep all cores:
    # e.g. sysctl -w kernel.core_pattern=/var/lib/istio/core.%e.%p.%t
    enableCoreDump: false

    # Default port for Pilot agent health checks. A value of 0 will disable health checking.
    statusPort: 15020

    # The initial delay for readiness probes in seconds.
    readinessInitialDelaySeconds: 1

    # The period between readiness probes.
    readinessPeriodSeconds: 2

    # The number of successive failed probes before indicating readiness failure.
    readinessFailureThreshold: 30

    # istio egress capture whitelist
    # https://istio.io/docs/tasks/traffic-management/egress.html#calling-external-services-directly
    # example: includeIPRanges: "172.30.0.0/16,172.20.0.0/16"
    # would only capture egress traffic on those two IP Ranges, all other outbound traffic would
    # be allowed by the sidecar
    includeIPRanges: "*"
    excludeIPRanges: ""

    # istio ingress capture whitelist
    # examples:
    #     Redirect no inbound traffic to Envoy:    --includeInboundPorts=""
    #     Redirect all inbound traffic to Envoy:   --includeInboundPorts="*"
    #     Redirect only selected ports:            --includeInboundPorts="80,8080"
    includeInboundPorts: "*"
    excludeInboundPorts: ""

    # This controls the 'policy' in the sidecar injector.
    autoInject: enabled

    # Sets the destination Statsd in envoy (the value of the "--statsdUdpAddress" proxy argument
    # would be <host>:<port>).
    # Disabled by default.
    # The istio-statsd-prom-bridge is deprecated and should not be used moving forward.
    envoyStatsd:
      # If enabled is set to true, host and port must also be provided. Istio no longer provides a statsd collector.
      enabled: false
      host: # example: statsd-svc
      port: # example: 9125

    # This controls the stats collection for proxies. To disable stats
    # collection, set the prometheusPort to 0.
    stats:
      prometheusPort: 15090

  proxy_init:
    # Base name for the proxy_init container, used to configure iptables.
    image: proxy_init

  # imagePullPolicy is applied to istio control plane components.
  # local tests require IfNotPresent, to avoid uploading to dockerhub.
  # TODO: Switch to Always as default, and override in the local tests.
  imagePullPolicy: IfNotPresent

  # controlPlaneMtls enabled. Will result in delays starting the pods while secrets are
  # propagated, not recommended for tests.
  controlPlaneSecurityEnabled: false

  # SDS enabled. IF set to true, mTLS certificates for the sidecars will be
  # distributed through the SecretDiscoveryService instead of using K8S secrets to mount the certificates.
  sdsEnabled: false

  # indicate the domain used in SPIFFE identity URL
  # The default depends on the environment.
  #   kubernetes: cluster.local
  #   else:  default dns domain
  identityDomain: cluster.local

  # disablePolicyChecks disables mixer policy checks.
  # Will set the value with same name in istio config map - pilot needs to be restarted to take effect.
  disablePolicyChecks: false

  # EnableTracing sets the value with same name in istio config map, requires pilot restart to take effect.
  enableTracing: true

  tracer:
    # Host:Port for reporting trace data in zipkin format. If not specified, will default to
    # zipkin service (port 9411) in the same namespace as the other istio components.
    zipkinAddress:

  # Default mtls policy. If true, mtls between services will be enabled by default.
  mtls:
    # Default setting for service-to-service mtls. Can be set explicitly using
    # destination rules or service annotations.
    enabled: false

  # ImagePullSecrets for all ServiceAccount, list of secrets in the same namespace
  # to use for pulling any images in pods that reference this ServiceAccount.
  # For components that don't use ServiceAccounts (i.e. grafana, servicegraph, tracing)
  # ImagePullSecrets will be added to the corresponding Deployment(StatefulSet) objects.
  # Must be set for any clustser configured with private docker registry.
  imagePullSecrets:
    # - private-registry-key

  # Specify pod scheduling arch(amd64, ppc64le, s390x) and weight as follows:
  #   0 - Never scheduled
  #   1 - Least preferred
  #   2 - No preference
  #   3 - Most preferred
  arch:
    amd64: 2
    s390x: 2
    ppc64le: 2

  # Whether to restrict the applications namespace the controller manages;
  # If not set, controller watches all namespaces
  oneNamespace: false

  # Whether to perform server-side validation of configuration.
  configValidation: true

  # If set to true, the pilot and citadel mtls will be exposed on the
  # ingress gateway
  meshExpansion:
    enabled: false
    # If set to true, the pilot and citadel mtls and the plain text pilot ports
    # will be exposed on an internal gateway
    useILB: false

  multiCluster:
    # Set to true to connect two kubernetes clusters using a LB gateway as
    # the only entry point into the cluster (instead of requiring pod to
    # pod connectivity across two clusters). Note that for this system to
    # work, service objects from remote clusters have to be replicated to
    # local cluster (without the pod selectors). In addition, service
    # entries have to be added for each replicated service object, where
    # the endpoints in the service entry point to the remote cluster's
    # mcgatewayIP:15443. All clusters should be using Istio mTLS and must
    # have a shared root CA for this model to work.
    connectUsingGateway: false

  # A minimal set of requested resources to applied to all deployments so that
  # Horizontal Pod Autoscaler will be able to function (if set).
  # Each component can overwrite these default values by adding its own resources
  # block in the relevant section below and setting the desired resources values.
  defaultResources:
    requests:
      cpu: 10m
    #   memory: 128Mi
    # limits:
    #   cpu: 100m
    #   memory: 128Mi

  # Not recommended for user to configure this. Hyperkube image to use when creating custom resources
  hyperkube:
    hub: quay.io/coreos
    tag: v1.7.6_coreos.0

  # Kubernetes >=v1.11.0 will create two PriorityClass, including system-cluster-critical and
  # system-node-critical, it is better to configure this in order to make sure your Istio pods
  # will not be killed because of low priority class.
  # Refer to https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass
  # for more detail.
  priorityClassName: ""

  # Include the crd definition when generating the template.
  # For 'helm template' and helm install > 2.10 it should be true.
  # For helm < 2.9, crds must be installed ahead of time with
  # 'kubectl apply -f install/kubernetes/helm/istio/templates/crds.yaml
  # and this options must be set off.
  crds: true

  # Use the Mesh Control Protocol (MCP) for configuring Mixer and
  # Pilot. Requires galley (`--set galley.enabled=true`).
  useMCP: false


<<<<<<< HEAD
||||||| merged common ancestors
#
# security configuration
#
security:
  enabled: true
  replicaCount: 1
  image: citadel
  selfSigned: true # indicate if self-signed CA is used.
  identityDomain: cluster.local # indicate the domain used in SPIFFE identity URL

#
# nodeagent configuration
#
nodeagent:
  enabled: false
  image: node-agent-k8s
  sdsudspath: ""
  env:
    CA_ADDR: ""

#
# addons configuration
#
telemetry-gateway:
  gatewayName: ingressgateway
  grafanaEnabled: false
  prometheusEnabled: false

grafana:
  enabled: false
  replicaCount: 1
  image:
    repository: grafana/grafana
    tag: 5.2.3
  persist: false
  storageClassName: ""
  security:
    enabled: false
    secretName: grafana
    usernameKey: username
    passphraseKey: passphrase
  service:
    annotations: {}
    name: http
    type: ClusterIP
    externalPort: 3000
    loadBalancerIP:
    loadBalancerSourceRanges:

prometheus:
  enabled: true
  replicaCount: 1
  hub: docker.io/prom
  tag: v2.3.1

  service:
    annotations: {}
    nodePort:
      enabled: false
      port: 32090

servicegraph:
  enabled: false
  replicaCount: 1
  image: servicegraph
  service:
    annotations: {}
    name: http
    type: ClusterIP
    externalPort: 8088
    loadBalancerIP:
    loadBalancerSourceRanges:
  ingress:
    enabled: false
    # Used to create an Ingress record.
    hosts:
      - servicegraph.local
    annotations:
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    tls:
      # Secrets must be manually created in the namespace.
      # - secretName: servicegraph-tls
      #   hosts:
      #     - servicegraph.local
  # prometheus address
  prometheusAddr: http://prometheus:9090

tracing:
  enabled: false
  provider: jaeger
  jaeger:
    hub: docker.io/jaegertracing
    tag: 1.7
    memory:
      max_traces: 50000
    ingress:
      enabled: false
      # Used to create an Ingress record.
      hosts:
        - jaeger.local
      annotations:
        # kubernetes.io/ingress.class: nginx
        # kubernetes.io/tls-acme: "true"
      tls:
        # Secrets must be manually created in the namespace.
        # - secretName: jaeger-tls
        #   hosts:
        #     - jaeger.local
  replicaCount: 1
  service:
    annotations: {}
    name: http
    type: ClusterIP
    externalPort: 9411
  ingress:
    enabled: false
    # Used to create an Ingress record.
    hosts:
      - tracing.local
    annotations:
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    tls:
      # Secrets must be manually created in the namespace.
      # - secretName: tracing-tls
      #   hosts:
      #     - tracing.local

kiali:
  enabled: false
  replicaCount: 1
  hub: docker.io/kiali
  tag: v0.7
  ingress:
    enabled: false
    ## Used to create an Ingress record.
    hosts:
     - kiali.local
    annotations:
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    tls:
      # Secrets must be manually created in the namespace.
      # - secretName: kiali-tls
      #   hosts:
      #     - kiali.local
  dashboard:
    secretName: kiali
    usernameKey: username
    passphraseKey: passphrase

    # Override the automatically detected Grafana URL, useful when Grafana service has no ExternalIPs
    # grafanaURL:

    # Override the automatically detected Jaeger URL, useful when Jaeger service has no ExternalIPs
    # jaegerURL:
  # prometheus address
  prometheusAddr: http://prometheus:9090

# Certmanager uses ACME to sign certificates. Since Istio gateways are
# mounting the TLS secrets the Certificate CRDs must be created in the
# istio-system namespace. Once the certificate has been created, the
# gateway must be updated by adding 'secretVolumes'. After the gateway
# restart, DestinationRules can be created using the ACME-signed certificates.
certmanager:
  enabled: false
  hub: quay.io/jetstack
  tag: v0.3.1
  resources: {}
=======
#
# security configuration
#
security:
  enabled: true
  replicaCount: 1
  image: citadel
  selfSigned: true # indicate if self-signed CA is used.

#
# nodeagent configuration
#
nodeagent:
  enabled: false
  image: node-agent-k8s
  sdsudspath: ""
  env:
    CA_ADDR: ""

#
# addons configuration
#
telemetry-gateway:
  gatewayName: ingressgateway
  grafanaEnabled: false
  prometheusEnabled: false

grafana:
  enabled: false
  replicaCount: 1
  image:
    repository: grafana/grafana
    tag: 5.2.3
  persist: false
  storageClassName: ""
  security:
    enabled: false
    secretName: grafana
    usernameKey: username
    passphraseKey: passphrase
  service:
    annotations: {}
    name: http
    type: ClusterIP
    externalPort: 3000
    loadBalancerIP:
    loadBalancerSourceRanges:

prometheus:
  enabled: true
  replicaCount: 1
  hub: docker.io/prom
  tag: v2.3.1

  service:
    annotations: {}
    nodePort:
      enabled: false
      port: 32090

servicegraph:
  enabled: false
  replicaCount: 1
  image: servicegraph
  service:
    annotations: {}
    name: http
    type: ClusterIP
    externalPort: 8088
    loadBalancerIP:
    loadBalancerSourceRanges:
  ingress:
    enabled: false
    # Used to create an Ingress record.
    hosts:
      - servicegraph.local
    annotations:
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    tls:
      # Secrets must be manually created in the namespace.
      # - secretName: servicegraph-tls
      #   hosts:
      #     - servicegraph.local
  # prometheus address
  prometheusAddr: http://prometheus:9090

tracing:
  enabled: false
  provider: jaeger
  jaeger:
    hub: docker.io/jaegertracing
    tag: 1.7
    memory:
      max_traces: 50000
    ingress:
      enabled: false
      # Used to create an Ingress record.
      hosts:
        - jaeger.local
      annotations:
        # kubernetes.io/ingress.class: nginx
        # kubernetes.io/tls-acme: "true"
      tls:
        # Secrets must be manually created in the namespace.
        # - secretName: jaeger-tls
        #   hosts:
        #     - jaeger.local
  replicaCount: 1
  service:
    annotations: {}
    name: http
    type: ClusterIP
    externalPort: 9411
  ingress:
    enabled: false
    # Used to create an Ingress record.
    hosts:
      - tracing.local
    annotations:
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    tls:
      # Secrets must be manually created in the namespace.
      # - secretName: tracing-tls
      #   hosts:
      #     - tracing.local

kiali:
  enabled: false
  replicaCount: 1
  hub: docker.io/kiali
  tag: v0.7
  ingress:
    enabled: false
    ## Used to create an Ingress record.
    hosts:
     - kiali.local
    annotations:
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    tls:
      # Secrets must be manually created in the namespace.
      # - secretName: kiali-tls
      #   hosts:
      #     - kiali.local
  dashboard:
    secretName: kiali
    usernameKey: username
    passphraseKey: passphrase

    # Override the automatically detected Grafana URL, useful when Grafana service has no ExternalIPs
    # grafanaURL:

    # Override the automatically detected Jaeger URL, useful when Jaeger service has no ExternalIPs
    # jaegerURL:
  # prometheus address
  prometheusAddr: http://prometheus:9090

# Certmanager uses ACME to sign certificates. Since Istio gateways are
# mounting the TLS secrets the Certificate CRDs must be created in the
# istio-system namespace. Once the certificate has been created, the
# gateway must be updated by adding 'secretVolumes'. After the gateway
# restart, DestinationRules can be created using the ACME-signed certificates.
certmanager:
  enabled: false
  hub: quay.io/jetstack
  tag: v0.3.1
  resources: {}
>>>>>>> Move value identityDomain to global scope.
